;
; PotterSoftware Quote Displayer V2.50 (A86, NASM, Yasm source code)
; (C) 1996--2022-03-27 by EplPáj of PotterSoftware, Hungary
;
; Compile it with NASM 0.98.39 .. 2.13.02 ...:
;
;   nasm -O0 -f bin -o quote5n.com quote5.8
;
; Alternatively, compile it with Yasm 1.2.0 or 1.3.0:
;
;   yasm -O0 -f bin -o quote5n.com quote5.8
;
; Alternatively, compile it with A86 3.22 .. 4.05 on DOS, generate quote5.com:
;
;   a86 quote5.8
;
; Reproduces the original quote5.com.orig (1192 bytes).
;
; This source file is for archival purposes only.
; Bugfixes and features shouldn't be added to this file, but to quote52.8.
;
; This program (quote5.com) is buggy (just like quote3.exe) in both DOSBox
; and QEMU, it usually hangs after printing the header correctly.
; It is because of the slow random number generator. It also has some other
; serious bugs, see BUG in the source code.
;
; This source code is based on the disassembly of quote.com generated by A86
; 3.22, and abstractions were added based on quote4.8 and quote6.8. The
; original, commented A86 source code was lost.
;
; The QUOTE.IDX index file format is identical in version 2.30 .. 2.5? and
; different from version 2.60.
;
; The most important update since V2.40 is that ANSI.SYS is no longer needed
; for color display. With ANSI.SYS, \x1B escapes were use when printing with
; with int 029h, now int 010h is used (color specified in bl, with AH=0Eh
; and AH=09h). The latter works in DOSBox as well.
;
; Command-line argument (first byte on the command-line):
;
; * ' '-> Display a quote using index table (default).
; * 'A'-> Display a quote using linear search.
; * 'B'-> Create index table & then display a quote using it.
; * 'C'-> Create index table.
;

; These magic lines below load the assembler compatibility library in file
; nasm.8, which makes the rest of the code work with the assemblers
; A86 >=3.22, NASM >=0.98.39, Yasm >=1.2.0. Please note that A86 3.22 doesn't
; support `include', so to make it work, replace these lines with the contents
; of the file nasm.8.
%define macro  ; NASM + Yasm code follows (no A86).
%macro include 1
%include %1
%endm
%define __EM__ #em  ; End of NASM + Yasm code.
include 'nasm.8'

org 100h
bits 16
cpu 286  ; Some instructions below (such as higher-than-1 bit shifts) need 286.

full equ 16384  ; Just a size (04000h).

_bss_data equ 018h  ; Overlaps the beginning of headermsg. Unfortunately it's not possible to precompute in A86 3.22.
;_bss_data equ headermsg  ; This forward-declaration doesn't work in A86.

; _bss variables.
qqq_a equ _bss_data-018h+018h  ; w
qqq_b equ _bss_data-018h+01Ah  ; w
qqq_w equ _bss_data-018h+01Ch  ; w
qqq_llw equ _bss_data-018h+01Eh  ; w
qqq_lhw equ _bss_data-018h+020h  ; w
qqq_maxlw equ _bss_data-018h+022h  ; w
qqq_maxhw equ _bss_data-018h+024h  ; w
qqq_oldllw equ _bss_data-018h+026h  ; w
qqq_oldlhw equ _bss_data-018h+028h  ; w
qqq_before equ _bss_data-018h+02Ah  ; w
qqq_xch equ _bss_data-018h+02Ch  ; b  ; Contains the command-line argument character: 0 for missing or space (' '), otherwise uppercased ('A' to 'C').
qqq_ansich equ _bss_data-018h+02Dh  ; b
qqq_han equ _bss_data-018h+02Eh  ; w  ; Filehandle.

_code:
_start:  ; begin { program entry point }
	; Increase DS and SS to accommodate for the total memory usage of 68 KiB (67
	; KiB for code and data + 1 KiB for stack).
	;
	; Here is how we could increase the memory usage to 68 KiB (67 KiB needed for code
	; and data + 1 KiB for stack):
	; mov ah, 04Ah  ; https://stanislavs.org/helppc/int_21-4a.html
	; mov bx, 01100h  ; Number of bytes needed == 1100h * 16, that's 68 KiB.
	; int 21h
	; Then abort if CF is set.
	mov ax, ds  ; @0x0100  8CD8
	add ax, word_arg(seg_delta)  ; @0x0102  055400
	mov ds, ax  ; @0x0105  8ED8
	mov ax, ss  ; @0x0107  8CD0
	add ax, 0100h  ; @0x0109  050001  ; 1 KiB of stack at the end of the 68 KiB.
	mov ss, ax  ; @0x010C  8ED0

	mov bh, 00h  ; @0x010E  B700
	mov ax, 0E0Dh  ; @0x0110  B80D0E
	int 010h  ; @0x0113  CD10
	mov al, 0Ah  ; @0x0115  B00A
	int 010h  ; @0x0117  CD10
	push_byte headermsg  ; @0x0119  6A18
	call func_Header  ; @0x011B  E89003
	mov al, [cs:081h]  ; @0x011E  2EA08100
	cmp al, ' '  ; @0x0122  3C20
	jnz lx_12a  ; @0x0124  7504
	mov al, [cs:082h]  ; @0x0126  2EA08200
lx_12a:	cmp byte [cs:080h], 00h  ; @0x012A  2E803E800000
	jnz lx_137  ; @0x0130  7505
	mov byte [qqq_xch], ' '  ; @0x0132  C6062C0020
lx_137:	and al, 255-32  ; @0x0137  24DF
	mov [qqq_xch], al  ; @0x0139  A22C00
	mov ax, ds  ; @0x013C  8CD8
	mov es, ax  ; @0x013E  8EC0
	; XReset(IdxFn);
	mov ax, 03D00h  ; @0x0140  B8003D
	mov dx, idxfn  ; @0x0143  BA0C00
	int 021h  ; @0x0146  CD21
	mov [qqq_han], ax  ; @0x0148  A32E00
	sbb ax, ax  ; @0x014B  1BC0
	mov word [offset idx], 00h  ; @0x014D  C7066D400000  ; idx[0]:=0
	cmp ax, word_arg(0)  ; @0x0153  3D0000
	jnz lx_162  ; @0x0156  750A
	cmp byte [qqq_xch], 13  ; @0x0158  803E2C000D
	jnz lx_162  ; @0x015D  7503
	jmp_near lls  ; @0x015F  E91101
lx_162:	; XReset(TXTFN);
	mov ax, 03D00h  ; @0x0162  B8003D
	mov dx, txtfn  ; @0x0165  BA0000
	int 021h  ; @0x0168  CD21
	mov [qqq_han], ax  ; @0x016A  A32E00
	jnc lx_172  ; @0x016D  7303
	jmp_near exit  ; @0x016F  E9F002
lx_172:	mov ax, 04202h  ; @0x0172  B80242
	mov bx, [qqq_han]  ; @0x0175  8B1E2E00
	xor cx, cx  ; @0x0179  33C9
	xor dx, dx  ; @0x017B  33D2
	int 021h  ; @0x017D  CD21
	mov [qqq_maxlw], ax  ; @0x017F  A32200
	mov [qqq_maxhw], dx  ; @0x0182  89162400
	mov ax, 04200h  ; @0x0186  B80042
	mov bx, [qqq_han]  ; @0x0189  8B1E2E00
	xor cx, cx  ; @0x018D  33C9
	xor dx, dx  ; @0x018F  33D2
	int 021h  ; @0x0191  CD21
	mov word [qqq_b], full+4  ; @0x0193  C7061A000440
	xor ax, ax  ; @0x0199  33C0
	mov [qqq_llw], ax  ; @0x019B  A31E00
	mov [qqq_lhw], ax  ; @0x019E  A32000
	mov [qqq_oldllw], ax  ; @0x01A1  A32600
	mov [qqq_oldlhw], ax  ; @0x01A4  A32800
	mov word [qqq_a], 01h  ; @0x01A7  C70618000100
lx_1ad:	call func_GetNext  ; @0x01AD  E8B602
	mov si, offset buf-4  ; @0x01B0  BE6400
	add si, [qqq_b]  ; @0x01B3  03361A00
	cmp word [si], 0A0Dh  ; @0x01B7  813C0D0A
	jnz lx_1f3  ; @0x01BB  7536
	cmp word [si+02h], 0A0Dh  ; @0x01BD  817C020D0A
	jnz lx_1f3  ; @0x01C2  752F
	mov ax, [qqq_llw]  ; @0x01C4  A11E00
	mov dx, [qqq_lhw]  ; @0x01C7  8B162000
	sub ax, [qqq_oldllw]  ; @0x01CB  2B062600
	sbb dx, [qqq_oldlhw]  ; @0x01CF  1B162800
	mov di, offset idx+0  ; @0x01D3  BF6D40
	add di, [qqq_a]  ; @0x01D6  033E1800
	add di, [qqq_a]  ; @0x01DA  033E1800
	mov [di], ax  ; @0x01DE  8905
	mov [di+02h], dx  ; @0x01E0  895502
	inc word [qqq_a]  ; @0x01E3  FF061800
	mov ax, [qqq_llw]  ; @0x01E7  A11E00
	mov [qqq_oldllw], ax  ; @0x01EA  A32600
	mov ax, [qqq_lhw]  ; @0x01ED  A12000
	mov [qqq_oldlhw], ax  ; @0x01F0  A32800
lx_1f3:	mov ax, [qqq_maxlw]  ; @0x01F3  A12200
	mov dx, [qqq_maxhw]  ; @0x01F6  8B162400
	cmp [qqq_llw], ax  ; @0x01FA  39061E00
	jnz lx_1ad  ; @0x01FE  75AD
	cmp [qqq_lhw], dx  ; @0x0200  39162000
	jnz lx_1ad  ; @0x0204  75A7
	mov ah, 03Eh  ; @0x0206  B43E
	mov bx, [qqq_han]  ; @0x0208  8B1E2E00
	int 021h  ; @0x020C  CD21
	cmp byte [qqq_xch], 'A'  ; @0x020E  803E2C0041
	jnz compress_index  ; @0x0213  7503
	jmp_near llc  ; @0x0215  E9AD00

compress_index:  ; Compresses the index from idx+2 to buf.
	; qqq_a is still the number of quotes.
	mov cx, [qqq_a]  ; @0x0218  8B0E1800
	dec cx  ; @0x021C  49
	mov si, offset idx+2  ; @0x021D  BE6F40
	mov ax, ds  ; @0x0220  8CD8
	mov es, ax  ; @0x0222  8EC0
	mov di, offset buf+0  ; @0x0224  BF6800
	xor dx, dx  ; @0x0227  33D2
lx_229:	lodsw  ; @0x0229  AD
	stosb  ; @0x022A  AA
	cmp ax, 0F0h  ; @0x022B  3DF000
	jc lx_238  ; @0x022E  7208
	dec di  ; @0x0230  4F
	rol ax, 8  ; @0x0231  C1C008
	or ax, 0F0h  ; @0x0234  0DF000
	stosw  ; @0x0237  AB
lx_238:	loop lx_229  ; @0x0238  E2EF
	mov [qqq_a], di  ; @0x023A  893E1800
	sub_word_byte qqq_a, offset buf+0  ; sub qqq_a, byte offset buf+0  ; @0x023E  832E180068
	mov ah, 03Ch  ; @0x0243  B43C
	mov cx, 00h  ; @0x0245  B90000
	mov dx, idxfn  ; @0x0248  BA0C00
	int 021h  ; @0x024B  CD21
	jnc lx_252  ; @0x024D  7303
	jmp_near exit  ; @0x024F  E91002
lx_252:	jnc lx_259  ; @0x0252  7305
	mov ax, 04CF0h  ; @0x0254  B8F04C
	int 021h  ; @0x0257  CD21
lx_259:	mov ah, 040h  ; @0x0259  B440
	mov bx, [qqq_han]  ; @0x025B  8B1E2E00
	mov cx, [qqq_a]  ; @0x025F  8B0E1800
	mov dx, offset buf+0  ; @0x0263  BA6800
	int 021h  ; @0x0266  CD21
	mov ah, 03Eh  ; @0x0268  B43E
	mov bx, [qqq_han]  ; @0x026A  8B1E2E00
	int 021h  ; @0x026E  CD21
	jmp_near llc  ; @0x0270  E95200

lls:	; XReset(IDXFN);
	mov ax, 03D00h  ; @0x0273  B8003D
	mov dx, idxfn  ; @0x0276  BA0C00
	int 021h  ; @0x0279  CD21
	mov [qqq_han], ax  ; @0x027B  A32E00
	jnc lx_283  ; @0x027E  7303
	jmp_near exit  ; @0x0280  E9DF01
lx_283:	mov ah, 03Fh  ; @0x0283  B43F
	mov bx, [qqq_han]  ; @0x0285  8B1E2E00
	mov cx, 0FFFFh  ; @0x0289  B9FFFF  ; BUG: To avoid buffer overflow, read just full+4 instead of $FFFF.
	mov dx, offset buf+0  ; @0x028C  BA6800
	int 021h  ; @0x028F  CD21
	mov [qqq_a], ax  ; @0x0291  A31800
	mov ah, 03Eh  ; @0x0294  B43E
	mov bx, [qqq_han]  ; @0x0296  8B1E2E00
	int 021h  ; @0x029A  CD21
	mov cx, [qqq_a]  ; @0x029C  8B0E1800

	; Decompresses the index from buf to idx+2.
	mov dx, 01h  ; @0x02A0  BA0100
	mov si, offset var_s+0  ; @0x02A3  BE6800
	mov di, offset idx+2  ; @0x02A6  BF6F40
	mov ax, ds  ; @0x02A9  8CD8
	mov es, ax  ; @0x02AB  8EC0
lx_2ad:	lodsb  ; @0x02AD  AC
	mov ah, 00h  ; @0x02AE  B400
	stosw  ; @0x02B0  AB
	cmp al, 0F0h  ; @0x02B1  3CF0
	jc lx_2be  ; @0x02B3  7209
	dec di  ; @0x02B5  4F
	dec di  ; @0x02B6  4F
	and al, 0Fh  ; @0x02B7  240F
	mov ah, al  ; @0x02B9  88C4
	lodsb  ; @0x02BB  AC
	stosw  ; @0x02BC  AB
	dec cx  ; @0x02BD  49
lx_2be:	inc dx  ; @0x02BE  42
	loop lx_2ad  ; @0x02BF  E2EC
	mov [qqq_a], dx  ; @0x02C1  89161800

llc:	cmp byte [qqq_xch], 'C'  ; @0x02C5  803E2C0043
	jnz lx_2cf  ; @0x02CA  7503
	jmp_near exit  ; @0x02CC  E99301
lx_2cf:	mov ax, 03D00h  ; @0x02CF  B8003D
	mov dx, txtfn  ; @0x02D2  BA0000
	int 021h  ; @0x02D5  CD21
	mov [qqq_han], ax  ; @0x02D7  A32E00
	jnc lx_2df  ; @0x02DA  7303
	jmp_near exit  ; @0x02DC  E98301

	; qqq_w:=random(qqq_a+1);  Then 0 <= qqq_w < qqq_a + 1.
	; This code may ruin AX, BX, CX, DX, SI, DI, BP and FLAGS.
	;
	; According to https://stanislavs.org/helppc/bios_data_area.html , dword [0x40:0x6c]
	; is the daily timer counter: equal to zero at midnight; incremented by INT 8;
	; read/set by int 0x1a. Thus this random number generator is very slow.
	;
	; First we generate a 16-bit random number based on the timer counter. The code for
	; this is ad hoc and messy.
lx_2df:	push es  ; @0x02DF  06
lx_2e0:	xor ax, ax  ; @0x02E0  33C0
	mov es, ax  ; @0x02E2  8EC0
	mov ax, [es:046Ch]  ; @0x02E4  26A16C04
	xor ax, [es:046Eh]  ; @0x02E8  2633066E04
	mov bx, dx  ; @0x02ED  89D3
	xor ax, bx  ; @0x02EF  31D8
	mov cx, [es:046Dh]  ; @0x02F1  268B0E6D04
	mov bx, 0E21h  ; @0x02F6  BB210E
lx_2f9:	mul bx  ; @0x02F9  F7E3
	add ax, 0BE0h  ; @0x02FB  05E00B
	loop lx_2f9  ; @0x02FE  E2F9
	; Now we have the 16-bit random number in ax. If it is small enough (qqq_a <= ax), 
	; then we are done, otherwise we generate another random number in a busy loop, also
	; waiting for int 0x8 timer to tick. Thus this random number generator is very slow.
	cmp ax, [qqq_a]  ; @0x0300  3B061800
	ja lx_2e0  ; @0x0304  77DA  ; BUG: This makes the random generator very slow.
	mov [qqq_w], ax  ; @0x0306  A31C00  ; Save random(qqq_a+1) to qqq_w.
	pop es  ; @0x0309  07

	mov word [qqq_llw], 00h  ; @0x030A  C7061E000000
	mov word [qqq_lhw], 00h  ; @0x0310  C70620000000
	mov si, offset idx+0  ; @0x0316  BE6D40
	add si, [qqq_w]  ; @0x0319  03361C00
	add si, [qqq_w]  ; @0x031D  03361C00
	std  ; @0x0321  FD
lx_322:	lodsw  ; @0x0322  AD
	add [qqq_llw], ax  ; @0x0323  01061E00
	adc word [qqq_lhw], byte_arg(0)  ; db 083h, 016h, qqq_lhw, 0, 0  ; @0x0327  8316200000
	cmp si, offset idx+0  ; @0x032C  81FE6D40
	jnz lx_322  ; @0x0330  75F0
	cld  ; @0x0332  FC

	mov dx, 0BFDAh  ; @0x0333  BADABF  ; '┌┐'  ; Keret ki
	call func_PrintLine  ; @0x0336  E8D401
lx_339:	mov ax, 04200h  ; @0x0339  B80042
	mov bx, [qqq_han]  ; @0x033C  8B1E2E00
	mov dx, [qqq_llw]  ; @0x0340  8B161E00
	mov cx, [qqq_lhw]  ; @0x0344  8B0E2000
	int 021h  ; @0x0348  CD21
	mov ah, 03Fh  ; @0x034A  B43F
	mov bx, [qqq_han]  ; @0x034C  8B1E2E00
	mov cx, 0FFh  ; @0x0350  B9FF00
	mov dx, offset var_s+1  ; @0x0353  BA6900
	int 021h  ; @0x0356  CD21
	mov [qqq_w], ax  ; @0x0358  A31C00
	cmp ax, word_arg(0)  ; @0x035B  3D0000
	jnz lx_363  ; @0x035E  7503
	jmp_near lx_448  ; @0x0360  E9E500
lx_363:	mov bx, 00h  ; @0x0363  BB0000
	mov si, offset var_s+1  ; @0x0366  BE6900
lx_369:	or bh, bh  ; @0x0369  0AFF
	jnz lx_375  ; @0x036B  7508
	cmp byte [bx+si], 0Dh  ; @0x036D  80380D
	jz lx_378  ; @0x0370  7406
	inc bx  ; @0x0372  43
	jmp short lx_369  ; @0x0373  EBF4
lx_375:	jmp_near exit  ; @0x0375  E9EA00  ; Error: Line longer than 255 bytes.
lx_378:	mov [offset var_s+0], bl  ; @0x0378  881E6800
	inc bx  ; @0x037C  43
	inc bx  ; @0x037D  43
	add [qqq_llw], bx  ; @0x037E  011E1E00
	adc word [qqq_lhw], byte_arg(0)  ; db 083h, 016h, qqq_lhw, 0, 0 ; @0x0382  8316200000
	mov cx, ds  ; @0x0387  8CD9
	mov si, offset var_s+0  ; @0x0389  BE6800
	mov [qqq_w], si  ; @0x038C  89361C00
	lodsb  ; @0x0390  AC
	cmp al, 00h  ; @0x0391  3C00
	jnz lx_39c  ; @0x0393  7507
	mov al, 01h  ; @0x0395  B001
	mov ds, cx  ; @0x0397  8ED9
	jmp_near lx_441  ; @0x0399  E9A500
lx_39c:	mov byte [qqq_ansich], 00h  ; @0x039C  C6062D0000
	cmp byte [si], '-'  ; @0x03A1  803C2D
	jnz lx_3b9  ; @0x03A4  7513
	mov al, [si+01h]  ; @0x03A6  8A4401
	mov [qqq_ansich], al  ; @0x03A9  A22D00
	add word [qqq_w], byte_arg(2)  ; db 083h, 006h, 01ch, 0, 2  ; @0x03AC  83061C0002
	mov al, [si-01h]  ; @0x03B1  8A44FF
	dec ax  ; @0x03B4  48
	dec ax  ; @0x03B5  48
	mov [si+01h], al  ; @0x03B6  884401
lx_3b9:	mov ah, 00h  ; @0x03B9  B400
	mov ds, cx  ; @0x03BB  8ED9
	mov bx, 04Eh  ; @0x03BD  BB4E00
	mov cx, 0Fh  ; @0x03C0  B90F00
	cmp byte [qqq_ansich], 00h  ; @0x03C3  803E2D0000
	jnz lx_3d5  ; @0x03C8  750B
	mov al, 00h  ; @0x03CA  B000
	mov bx, 00h  ; @0x03CC  BB0000
	mov cx, 07h  ; @0x03CF  B90700
	jmp_near lx_3e4  ; @0x03D2  E90F00
lx_3d5:	cmp byte [qqq_ansich], '&'  ; @0x03D5  803E2D0026
	jnz lx_3e4  ; @0x03DA  7508
	mov bx, 027h  ; @0x03DC  BB2700
	shr ax, 1  ; @0x03DF  D1E8
	mov cx, 0Ah  ; @0x03E1  B90A00
lx_3e4:	sub bx, ax  ; @0x03E4  29C3
	mov [qqq_before], bx  ; @0x03E6  891E2A00
	mov ax, 0EB3h  ; @0x03EA  B8B30E
	mov bh, 00h  ; @0x03ED  B700
	int 010h  ; @0x03EF  CD10
	mov bx, cx  ; @0x03F1  8BD9
	mov cx, 04Eh  ; @0x03F3  B94E00
	call func_Print_spaces  ; @0x03F6  E82D01
	push ds  ; @0x03F9  1E
	mov si, [qqq_w]  ; @0x03FA  8B361C00
	lodsb  ; @0x03FE  AC
	mov cl, al  ; @0x03FF  88C1
	mov ch, 00h  ; @0x0401  B500
	mov dx, cx  ; @0x0403  8BD1
	jcxz lx_437  ; @0x0405  E330
	mov cx, [qqq_before]  ; @0x0407  8B0E2A00
	jcxz lx_416  ; @0x040B  E309
	mov ax, 0E20h  ; @0x040D  B8200E
	mov bh, 00h  ; @0x0410  B700
lx_412:	int 010h  ; @0x0412  CD10
	loop lx_412  ; @0x0414  E2FC
lx_416:	mov cx, dx  ; @0x0416  8BCA
	jcxz lx_423  ; @0x0418  E309
	mov ah, 0Eh  ; @0x041A  B40E
	mov bh, 00h  ; @0x041C  B700
lx_41e:	lodsb  ; @0x041E  AC
	int 010h  ; @0x041F  CD10
	loop lx_41e  ; @0x0421  E2FB
lx_423:	mov cx, 04Eh  ; @0x0423  B94E00
	sub cx, [qqq_before]  ; @0x0426  2B0E2A00
	sub cx, dx  ; @0x042A  29D1
	jcxz lx_437  ; @0x042C  E309
	mov ax, 0E20h  ; @0x042E  B8200E
	mov bh, 00h  ; @0x0431  B700
lx_433:	int 010h  ; @0x0433  CD10
	loop lx_433  ; @0x0435  E2FC
lx_437:	pop ds  ; @0x0437  1F
	mov ax, 0EB3h  ; @0x0438  B8B30E
	mov bh, 00h  ; @0x043B  B700
	int 010h  ; @0x043D  CD10
	mov al, 00h  ; @0x043F  B000
lx_441:	or al, al  ; @0x0441  0AC0
	jnz lx_448  ; @0x0443  7503
	jmp_near lx_339  ; @0x0445  E9F1FE
lx_448:	mov dx, 0D9C0h  ; @0x0448  BAC0D9
	call func_PrintLine  ; @0x044B  E8BF00
	push ds  ; @0x044E  1E
	push_byte footermsg  ; @0x044F  6A3B
	call func_Header  ; @0x0451  E85A00
	mov ah, 03Eh  ; @0x0454  B43E
	mov bx, [qqq_han]  ; @0x0456  8B1E2E00
	int 021h  ; @0x045A  CD21
	mov bx, 07h  ; @0x045C  BB0700
	call func_Print_80_spaces  ; @0x045F  E8C100
exit:	mov ah, 04Ch  ; @0x0462  B44C
	int 021h  ; @0x0464  CD21  ; Exit to DOS, with arbitrary exit code. BUG: should be EXIT_SUCCESS (0).

	; May ruin SI and possibly other registers.
func_GetNext:
	cmp word [qqq_b], full+4  ; @0x0466  813E1A000440
	jnz lx_498  ; @0x046C  752A
	; move(src:=buf[full], dst:=buf[0], 4);
	  ; BUG: This code is completely buggy. It should be:
	  ; mov si, offset buf + full
	  ; mov di, offset buf + 0
	  ; movsw
	  ; movsw
	  ; TODO: Did we forward-declare buf in the original?
	  xor_di_byte offset buf+0  ; xor di, byte buf  ; @0x046E  83F768
	  add di, full  ; @0x0471  81C70040
	  mov ax, word [offset buf+0]  ; @0x0475  A16800
	  stosw  ; @0x0478  AB
	  mov ax, word [offset buf+2]  ; @0x0479  A16A00
	  stosw  ; @0x047C  AB
	mov ah, 03Fh  ; @0x047D  B43F
	mov bx, [qqq_han]  ; @0x047F  8B1E2E00
	mov cx, full  ; @0x0483  B90040
	mov dx, offset buf+4  ; @0x0486  BA6C00
	int 021h  ; @0x0489  CD21
	jnz lx_492  ; @0x048B  7505  ; BUG: should be jnc.
	mov ax, 04CF1h  ; @0x048D  B8F14C  ; Abort on read error.
	int 021h  ; @0x0490  CD21
lx_492:	mov word [qqq_b], 04h  ; @0x0492  C7061A000400
lx_498:	mov bx, [qqq_b]  ; @0x0498  8B1E1A00
	mov_al_bx_byte offset buf+0  ; @0x049C  8A4768
	inc word [qqq_b]  ; @0x049F  FF061A00
	add word [qqq_llw], byte_arg(1)  ; db 083h, 006h, qqq_llw, 0, 1 ; @0x04A3  83061E0001
	adc word [qqq_lhw], byte_arg(0)  ; db 083h, 016h, qqq_lhw, 0, 0 ; @0x04A8  8316200000
	ret  ; @0x04AD  C3

func_Header:
	push bp  ; @0x04AE  55
	mov bp, sp  ; @0x04AF  89E5
	mov bx, 010h  ; @0x04B1  BB1000
	call func_Print_80_spaces  ; @0x04B4  E86C00
	mov ax, 0EB2h  ; @0x04B7  B8B20E
	mov byte [cs:ploop2], 048h  ; @0x04BA  2EC606390548  ; 48h: DEC AX
	call func_Print_header_side  ; @0x04C0  E86900
	mov si, [bp+04h]  ; @0x04C3  8B7604
	lodsb  ; @0x04C6  AC
	mov ah, 00h  ; @0x04C7  B400
	mov dx, ax  ; @0x04C9  8BD0
	shr ax, 1  ; @0x04CB  D1E8
	mov cx, 019h  ; @0x04CD  B91900
	sub cx, ax  ; @0x04D0  2BC8
	mov bp, cx  ; @0x04D2  89CD
	mov ax, 0E20h  ; @0x04D4  B8200E
	mov bh, 00h  ; @0x04D7  B700
	jcxz lx_4df  ; @0x04D9  E304
lx_4db:	int 010h  ; @0x04DB  CD10
	loop lx_4db  ; @0x04DD  E2FC
lx_4df:	mov cx, [si-01h]  ; @0x04DF  8B4CFF
	mov ch, 00h  ; @0x04E2  B500
lx_4e4:	lodsb  ; @0x04E4  AC
	int 010h  ; @0x04E5  CD10
	loop lx_4e4  ; @0x04E7  E2FB
	mov cx, 032h  ; @0x04E9  B93200
	sub cx, bp  ; @0x04EC  2BCD
	sub cx, dx  ; @0x04EE  29D1
	mov al, 020h  ; @0x04F0  B020
	jcxz lx_4f8  ; @0x04F2  E304
lx_4f4:	int 010h  ; @0x04F4  CD10
	loop lx_4f4  ; @0x04F6  E2FC
lx_4f8:	mov al, 0B0h  ; @0x04F8  B0B0
	mov byte [cs:ploop2], 040h  ; @0x04FA  2EC606390540  ; 40h: INC AX
	call func_Print_header_side  ; @0x0500  E82900
	mov bx, 07h  ; @0x0503  BB0700
	call func_Print_80_spaces  ; @0x0506  E81A00
	pop bp  ; @0x0509  5D
	ret 02h  ; @0x050A  C20200

func_PrintLine:	mov ah, 0Eh  ; @0x050D  B40E
	mov bh, 00h  ; @0x050F  B700
	mov al, dl  ; @0x0511  8AC2
	int 010h  ; @0x0513  CD10
	mov cx, 04Eh  ; @0x0515  B94E00
	mov al, 0C4h  ; @0x0518  B0C4
lx_51a:	int 010h  ; @0x051A  CD10
	loop lx_51a  ; @0x051C  E2FC
	mov al, dh  ; @0x051E  8AC6
	int 010h  ; @0x0520  CD10
	ret  ; @0x0522  C3

func_Print_80_spaces:  ; Prints 80 spaces with attributes in BX.
	mov cx, 80  ; @0x0523  B95000
func_Print_spaces:  ; Prints CX spaces with attributes in BX.
	mov ax, 0920h  ; @0x0526  B82009
	int 010h  ; @0x0529  CD10
	ret  ; @0x052B  C3

func_Print_header_side:  ; Prints the left or right side of the header.
	mov cx, 03h  ; @0x052C  B90300
lx_52f:	int 010h  ; @0x052F  CD10
	int 010h  ; @0x0531  CD10
	int 010h  ; @0x0533  CD10
	int 010h  ; @0x0535  CD10
	int 010h  ; @0x0537  CD10
ploop2:	dec ax  ; @0x0539  48  ; Self-modifying code will modify this to `dec ax' or `inc ax'.
	loop lx_52f  ; @0x053A  E2F3
	ret  ; @0x053C  C3

_code_padding:
	times_db ((_code - $) AND 15), 09Eh  ; Align to paragraph (16) boundary with sahf.
seg_delta equ (($-_code) SHR 4) + 10h

; Data with initial value (_data).
_data:
txtfn_in_data: db 'QUOTE.TXT', 0, 0, 0  ; Extra 0s because of _bss overlap with headermsg.
txtfn equ txtfn_in_data-_data  ; Because of seg_delta.
idxfn_in_data: db 'QUOTE.IDX', 0, 0, 0  ; Extra 0s because of _bss overlap with headermsg.
idxfn equ idxfn_in_data-_data  ; Because of seg_delta.
;_bss_data equ $-_data  ; It's too late to define a forward reference like this in A86 3.22.
; Must be long enough (23 bytes) for overlap with qqq_... .
headermsg_in_data: db 34, 'PotterSoftware Quote Displayer 2.5'
headermsg equ headermsg_in_data-_data  ; Because of seg_delta.
footermsg_in_data: db 44, 'Greetings to RP,TT,FZ/S,Blala,OGY,FC,VR,JCR.'
footermsg equ footermsg_in_data-_data  ; Because of seg_delta.
_data_end:

; More _bss: (Uninitialized data.)
buf equ _data_end-_data+((_data_end-_data) AND 1)  ; array[0..full+4-1] of char;  ; full+1+4 bytes used for multiple purposes.  ; Aligned.
var_s equ buf  ; string; overlaps buf
idx equ buf+full+1+4  ; array[0..24160] of word;  ; Unaligned. idx[0] is unused.

assert0 _bss_data-headermsg  ; Make sure `_bss_data equ' above is correct.

; -*- coding: utf-8 -*-
;
; quote4.nasm: PotterSoftware Quote Displayer V2.41 (NASM source code)
; (C) 1996--2022-3-27 by EplPáj of PotterSoftware, Hungary
; translation to NASM on 2022-3-27
;
; Compile it with NASM 0.98.39 .. 2.13.2 ...:
;
;   $ nasm -O0 -f bin -o quote4n.com quote4.nasm
;
; Alternatively, compile it with Yasm 1.2.0 or 1.3.0:
;
;   $ yasm -O0 -f bin -o quote4n.com quote4.nasm
;
; This source file is for archival purposes only.
; Bugfixes and features shouldn't be added to this file, but to quote42.nasm.
;
; This program (quote4n.com) is buggy (just like quote3.exe) in both DOSBox
; and QEMU, it usually hangs after printing the header correctly.
; It is because of the slow random number generator. It also has some other
; serious bugs, see BUG in the source code.
;
; This is version 2.41. It is functionally equivalent to version 2.33, but
; it's implemented in NASM (rather than Turbo Pascal 7.0 inline assembly).
; The original source code for version 2.40 was implemented in A86, but that
; has been lost.
;
; The QUOTE.IDX index file format is identical in version 2.30 .. 2.5? and
; different from version 2.60.
;
; This source code is based on the disassembly of quote3.exe generated by
; the Turbo Pascal compiler (tp70), but it has been changed since then to
; make it work as a DOS .com program, and it is also based on the source
; code quote3.pas (mostly for comments).
;
; It uses ANSI.SYS for color output, and it detects the lack of ANSI.SYS
; (such as in DOSBox), and then it prints colorless output.
;
; Command-line argument (first byte on the command-line):
;
; * ' '-> Display a quote using index table (default).
; * 'A'-> Display a quote using linear search.
; * 'B'-> Create index table & then display a quote using it.
; * 'C'-> Create index table.
;

bits 16
cpu 286
org 100h

_code:
_start:  ; begin { Főprogram }
	; Increase DS and SS to accommodate for the total memory usage of 68 KiB (67
	; KiB for code and data + 1 KiB for stack).
	mov ah, 4Ah  ; https://stanislavs.org/helppc/int_21-4a.html
	mov bx, 1100h  ; Number of bytes needed == 1100h * 16, that's 68 KiB.
	int 21h
	jnc strict short resize_ok
	jmp strict near fatal_error
resize_ok:
	mov ax, ds
	add ax, seg_delta
	mov ds, ax
	mov es, ax  ; es will remain this way for most of the rest of the run.
	mov ax, ss
	add ax, 100h  ; 1 KiB of stack at the end of the 68 KiB.
	mov ss, ax
	
main:	mov al, 13  ; Writeln
	int 29h
	mov al, 10
	int 29h

	push ds  ; Header ki
	push strict word headermsg
	call func_Header
	
	; Detect ANSI.SYS.
	;
	; From http://www.osfree.org/doku/en:docs:dos:api:int29 :
	; COMMAND.COM v3.2 and v3.3 compare the INT 29 vector against the INT 20
	; vector and assume that ANSI.SYS is installed if the segment is larger.
	push es
	xor ax, ax
	mov es, ax
	mov bx, [es:29h*4+2]  ; ansi:=memw[0:$29*4+2]>memw[0:$20*4+2];
	cmp bx, [es:20h*4+2]
	pop es
	jae strict short @95
	mov byte [ttt], '*'  ; This means there's no ANSI.SYS
@95:

	mov al, [81h]  ; First character of command-line arguments in PSP.  ; xch:=char(mem[PrefixSeg:$81]);
	cmp al, ' '
	jne strict short @96  ; if xch=' ' then xch:=char(mem[PrefixSeg:$82]);
	mov al, [82h]
@96:	cmp byte [80h], 0h  ; if mem[PrefixSeg:$80]=0 then xch:=' ';
	jne strict short @94
	mov al, ' '
@94:	and al, 255-32
	mov [qqq_xch], al
	; qqq_w:=XReset(IdxFn);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, idxfn
	int 21h
	mov [qqq_han], ax
	sbb ax, ax  ; AX:=0, ha OK ; AX:=$FFFF, ha hiba
	mov word [idx], 0  ; idx[0]:=0
	cmp ax, strict word 0  ; if (IOResult<>0) or (xch<>#0) then
	jne strict short @90
	cmp byte [qqq_xch], 0
	jne strict short @90
	jmp strict near lls
@90:	; XReset(TXTFN);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, txtfn
	int 21h
	;jc strict near fatal_error  ; BUG: Fail.
	mov [qqq_han], ax
	sbb ax, ax
	; qqq_max:=filesize(f);
	mov ax, 4202h
	mov bx, [qqq_han]
	xor cx, cx
	xor dx, dx
	int 21h
	mov [qqq_max], ax
	mov [qqq_max+2], dx
	mov ax, 4200h
	mov bx, [qqq_han]
	xor cx, cx
	xor dx, dx
	int 21h
	mov word [qqq_b], full+4  ; b:=full+4
	xor ax, ax
	mov [qqq_l], ax  ; l:=0
	mov [qqq_l+2], ax
	mov [qqq_oldl], ax  ; oldl:=0
	mov [qqq_oldl+2], ax
	mov word [qqq_a], 1
@81:	; repeat
	call func_GetNext
	mov si, buf-4
	add si, [qqq_b]
	cmp word [si], 0A0Dh  ; CRLF
	jne strict short @82
	cmp word [si+2h], 0A0Dh  ; CRLF
	jne strict short @82  ;  if buf[b-4]=newline then begin
	mov ax, [qqq_l]  ;    idx[a]:=l-oldl
	mov dx, [qqq_l+2]
	sub ax, [qqq_oldl]
	sbb dx, [qqq_oldl+2]
	mov di, idx
	add di, [qqq_a]
	add di, [qqq_a]
	mov [di], ax
	mov [di+2], dx
	inc word [qqq_a]
	mov ax, [qqq_l]  ;    oldl:=l
	mov [qqq_oldl], ax
	mov ax, [qqq_l+2]
	mov [qqq_oldl+2], ax  ;  end;
@82:	mov ax, [qqq_max]  ; until l=max
	mov dx, [qqq_max+2]
	cmp [qqq_l], ax
	jne strict short @81
	cmp [qqq_l+2], dx
	jne strict short @81
	
	; Close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h
	cmp byte [qqq_xch], 'A'  ; Nem írjuk ki az IT-t, ha az A par. van
	jne strict short @82_ne
	jmp strict near llc
@82_ne:	mov cx, [qqq_a]
	dec cx
	mov si, idx+2
	mov di, buf
	xor dx, dx
@83:	lodsw
	stosb
	cmp ax, 240
	jb strict short @84
	dec di
	rol ax, byte 8
	or ax, 240  ; 11110000b
	stosw
@84:	loop @83
	mov [qqq_a], di
	sub word [qqq_a], buf
	
	; XRewrite(IDXFN);
	mov ah, 3Ch  ; Create file
	mov cx, 0
	mov dx, idxfn
	int 21h
	jnc strict short @91
fatal_error:
	mov ax, 4CF0h  ; Fatal error
	int 21h
	; blockwrite(f, buf, qqq_a);
@91:	mov ah, 40h
	mov bx, [qqq_han]
	mov cx, [qqq_a]
	mov dx, buf
	int 21h
	; close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h
	; goto c;
	jmp strict short llc
	
lls:  ; end else begin
	; XReset(IDXFN);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, idxfn
	int 21h
	;jc strict near fatal_error  ; BUG: Fail.
	mov [qqq_han], ax
	sbb ax, ax
	; blockread(f, buf, $FFFF, qqq_a);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, 0FFFFh  ; BUG: To avoid buffer overflow, read just full+4 instead of $FFFF.
	mov dx, buf
	int 21h
	mov [qqq_a], ax  ; Save number of (compressed) bytes read to qqq_a.
	; close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h
	
	mov cx, [qqq_a]
	mov dx, 1
	mov si, buf
	mov di, idx+2
@85:	lodsb
	mov ah, 0
	stosw
	cmp al, 240
	jb strict short @86
	dec di
	dec di
	and al, 15
	mov ah, al
	lodsb
	stosw
	dec cx
@86:	inc dx
	loop @85
	mov [qqq_a], dx
llc:	cmp byte [qqq_xch], 'C'
	jne strict short @ne2
	jmp strict near llf
	; XReset(TXTFN);
@ne2:	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, txtfn
	int 21h
	;jc strict near fatal_error  ; BUG: Fail.
	mov [qqq_han], ax
	sbb ax, ax
	
	; qqq_w:=random(qqq_a+1);  Then 0 <= qqq_w < qqq_a + 1.
	;
	; According to https://stanislavs.org/helppc/bios_data_area.html , dword [40h:6Ch]
	; is the daily timer counter: equal to zero at midnight; incremented by INT 8;
	; read/set by int 1Ah. Thus this random number generator is very slow.
	;
	; First we generate a 16-bit random number based on the timer counter. The code for
	; this is ad hoc and messy.
	push es
@98:	xor ax, ax
	mov es, ax
	mov ax, [es:46Ch]
	xor ax, [es:46Eh]
	mov bx, dx
	xor ax, bx
	mov cx, [es:46Dh]
	mov bx, 0E21h
@99:	mul bx
	add ax, 0BE0h
	loop @99
	; Now we have the 16-bit random number in ax. If it is small enough (qqq_a <= ax),
	; then we are done, otherwise we generate another random number in a busy loop, also
	; waiting for int 8h timer to tick. Thus this random number generator is very slow.
	cmp ax, [qqq_a]
	ja strict short @98  ; BUG: This makes the random generator very slow.
	mov [qqq_w], ax  ; Save random(qqq_a+1) to qqq_w.
	pop es
	
	mov word [qqq_l], 0  ; L kezdőoffszet kiszámolása
	mov word [qqq_l+2], 0
	mov si, idx
	add si, [qqq_w]
	add si, [qqq_w]
	std
@97:	lodsw  ; L:=IDX[W]+IDX[W-1]+...+IDX[1]
	add [qqq_l], ax
	adc word [qqq_l+2], byte 0
	cmp si, idx
	jne strict short @97
	cld
	push strict word 0BFDAh  ; '┌┐'  ; Keret ki
	call func_PrintLine
	
lld:	; seek(f, qqq_l);
	mov ax, 4200h
	mov bx, [qqq_han]
	mov dx, [qqq_l]
	mov cx, [qqq_l+2]
	int 21h
	; blockread(f, s[1], 255, qqq_w);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, 255
	mov dx, var_s+1
	int 21h
	mov [qqq_w], ax
	
	cmp word [qqq_w], byte +0h  ; Stop at EOF
	jne strict short @ne1
	jmp strict near lle
@ne1:	mov bx, 0h  ; Look for #13 to determine length(s)
	mov si, var_s+1
@12:	or bh, bh
	jnz strict short @13
	cmp byte [si+bx], 13
	je strict short @11
	inc bx
	jmp strict short @12
@13:	jmp strict near llf  ; Error: Line longer than 255 bytes.
@11:	; Beállítjuk a string hosszát
	dw 1E88h, var_s  ; mov byte [var_s], bl  ; Workaround to prevent bug in yasm-1.2.0 and yasm-1.3.0: INTERNAL ERROR at modules/arch/x86/x86expr.c, line 417: unexpected expr op
	inc bx
	inc bx
	add [qqq_l], bx  ; inc(l,length(s)+2);
	adc word [qqq_l+2], byte 0
	
	; START OF ALIGN
	;
	; If S='' align returns TRUE else it returns FALSE. Align prints S with the
	; correct color & alignment according to the control codes found in S[1, 2].
	
	; Calculate the value of BEFORE first using up AnsiCh: #0=Left '-'=Right
	; '&'=Center alignment
	mov cx, ds
	mov si, var_s
	mov [qqq_w], si
	lodsb
	cmp al, 0
	jne strict short @d
	mov al, 1
	mov ds, cx
	jmp strict near @9  ; Empty string: do nothing but restore original CS
@d:	mov byte [qqq_ansich], 0  ; AnsiCh is 0 by default
	cmp byte [si], '-'
	jne strict short @c
	mov al, [si+1]
	mov [qqq_ansich], al
	add word [qqq_w], byte 2  ; If not AnsiCh<>0 the 1st 2 char won't be in the str
	mov al, [si-1]
	dec ax
	dec ax
	mov [si+1h], al
@c:	mov ah, 0
	mov ds, cx
	mov bx, 78
	cmp byte [qqq_ansich], 0
	jne strict short @a
	mov al, 0
	mov bx, 0
@a:	cmp byte [qqq_ansich], '&'
	jne strict short @b
	mov bx, 39
	shr ax, 1
@b:	sub bx, ax
	mov [qqq_before], bx
	mov al, 0B3h  ; '│'  ; The line starts by this
	int 29h
	cmp byte [ttt], '*'  ; Put out an ANSI EscSeq to set color if needed
	je strict short @6
	mov ah, 9
	mov al, [qqq_ansich]
	cmp al, 0
	je strict short @6
	add al, 10
	mov [ttt+17+3], al
	mov dx, ttt+17
	int 21h
	mov byte [qqq_ansich], 0h
@6:	push ds  ; Display the string "s" with "before" spaces in front of it
	mov si, [qqq_w]
	lodsb
	mov cl, al
	mov ch, 0
	mov dx, cx
	jcxz @1
	mov cx, [qqq_before]
	jcxz @5
	mov al, ' '
@2:	int 29h
	loop @2
@5:	mov cx, dx
	jcxz @8
@3:	lodsb
	int 29h
	loop @3
@8:	mov cx, 78
	sub cx, [qqq_before]
	sub cx, dx
	jcxz @1
	mov al, ' '
@4:	int 29h
	loop @4
@1:	pop ds
	cmp byte [ttt], '*'  ; Restore original color via ANSI EscSeq if needed
	je strict short @7
	mov ah, 9
	mov dx, ttt+25
	int 21h
@7:	mov al, 0B3h  ; '│'  ; The line ends by this, too
	int 29h
	mov al, 0 ; The return value is FALSE
	; END OF ALIGN
	
@9:	or al, al
	jnz strict short lle
	jmp strict near lld  ; Ha FALSE-t ad vissza, még van köv. sor, Különben lábléc és program vége
	
lle:	push strict word 0D9C0h  ; '└┘'
	call func_PrintLine
	push ds
	push strict word footermsg
	call func_Header
	mov ah, 3Eh  ; Close(F);
	mov bx, [qqq_han]
	int 21h
llf:	mov ax, 4C00h  ; EXIT_SUCCESS.
	int 21h  ; Exit to DOS.
	
; function GetNext: char; assembler;
func_GetNext:
	cmp word [qqq_b], full+4  ; if qqq_b=full+4 then begin
	jne strict short @88  ; No special meaning for @ in nasm, it's just a normal label character.
	; move(src:=buf[full], dst:=buf[0], 4);
	  ; BUG: This code is completely buggy. It should be:
	  ; mov si, buf + full
	  ; mov di, buf
	  ; movsw
	  ; movsw
	  xor di, buf
	  add di, full
	  mov ax, [buf]
	  stosw
	  mov ax, [buf+2]
	  stosw
	; blockread(f, buf[4], full, qqq_w);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, full
	mov dx, buf+4
	int 21h
	jnz strict short @87  ; BUG: should be jnc.
	mov ax, 4CF1h  ; Abort on read error.
	int 21h
@87:	mov word [qqq_b], 4  ; endif
@88:	mov bx, [qqq_b]  ; GetNext:=Buf[qqq_B];
	mov al, [bx+buf]
	inc word [qqq_b]
	add word [qqq_l], byte 1  ; inc(qqq_l);
	adc word [qqq_l+2], byte 0
	ret
	
; procedure Header(const s: OpenString); assembler;
func_Header:
%define Header_arg_s (bp+4)
	push bp
	mov bp, sp
	cmp byte [ttt], '*'
	je strict short @71
	mov dx, ttt+25
	mov ah, 9
	int 21h
	mov dx, ttt
	mov ah, 9
	int 21h
@71:	mov al, 0B2h  ; '▓'
	mov cx, 3
@72:	int 29h
	int 29h
	int 29h
	int 29h
	int 29h
	dec al
	loop @72
	push ds
	lds si, [Header_arg_s]
	lodsb
	mov ah, 0
	mov dx, ax
	shr ax, 1
	mov cx, 25
	sub cx, ax
	mov bx, cx
	mov al, ' '
	jcxz @74
@75:	int 29h
	loop @75
@74:	mov cx, [si-1]
	mov ch, 0h
@76:	lodsb
	int 29h
	loop @76
	pop ds
	mov cx, 50
	sub cx, bx
	sub cx, dx
	mov al, ' '
	jcxz @78
@77:	int 29h
	loop @77
@78:	mov al, 0B0h  ; '░'
	mov cx, 3
@73:	int 29h
	int 29h
	int 29h
	int 29h
	int 29h
	inc al
	loop @73
	cmp byte [ttt], '*'
	je strict short @79
	mov dx, ttt+9
	mov ah, 9h
	int 21h
@79:	leave
	ret 4
	
; procedure PrintLine(w: word); assembler;
func_PrintLine:
%define PrintLine_arg_w (bp+4)
	push bp
	mov bp, sp
	mov al, [PrintLine_arg_w]
	int 29h
	mov cx, 78
	mov al, 0C4h  ; '─'
@70:	int 29h
	loop @70
	mov al, [PrintLine_arg_w+1]
	int 29h
	leave
	ret 2

_code_padding:
	times ((_code-$) & 15) nop  ; Align to paragraph (16) boundary with nop.
seg_delta equ (($-_code) >> 4) + 10h

_data:
ttt_in_data: db 27, '[44;30m$', 27, '[0m', 27, '[K$', 27, '[30;1m$', 27, '[0m$'
ttt equ ttt_in_data-_data  ; Because of seg_delta.
txtfn_in_data: db 'QUOTE.TXT', 0
txtfn equ txtfn_in_data-_data  ; Because of seg_delta.
idxfn_in_data: db 'QUOTE.IDX', 0
idxfn equ idxfn_in_data-_data  ; Because of seg_delta.
; Must be long enough (23 bytes) for overlap with qqq_... .
headermsg_in_data: db 35, 'PotterSoftware Quote Displayer 2.41'
headermsg equ headermsg_in_data-_data  ; Because of seg_delta.
footermsg_in_data: db 44, 'Greetings to RP,TT,FZ/S,Blala,OGY,FC,VR,JCR.'
footermsg equ footermsg_in_data-_data  ; Because of seg_delta.
_data_end:

; _bss: (Uninitialized data.)
full equ 16384  ; Just a size.
buf equ _data_end+((_data_end-$$)&1)-_data  ; array[0..full+4-1] of char;  Aligned.
var_s equ buf  ; string; overlaps buf
idx equ buf+full+4+((buf+_data+full+4-$$)&1)  ; array[0..24160] of word;  ; Aligned. idx[0] is unused.
qqq_a equ headermsg  ; word; overlaps headermsg.
qqq_b equ qqq_a+2  ; word; overlaps headermsg.
qqq_w equ qqq_b+2  ; word; overlaps headermsg.
qqq_l equ qqq_w+2  ; longint; overlaps headermsg.
qqq_max equ qqq_l+4  ; longint; overlaps headermsg.
qqq_oldl equ qqq_max+4  ; longint; overlaps headermsg.
qqq_xch equ qqq_oldl+4  ; char; overlaps headermsg. Contains the command-line argument character: 0 for missing or space (' '), otherwise uppercased ('A' to 'C').
qqq_before equ qqq_xch+1  ; word; overlaps headermsg, Not aligned.
qqq_ansich equ qqq_before+2  ; char; overlaps headermsg.
qqq_han equ qqq_ansich+1  ; word; overlaps headermsg. Filehandle.

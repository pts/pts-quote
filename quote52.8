;
; PotterSoftware Quote Displayer V2.52 (disassembled from .com as A86 3.22 source code)
; (C) 1996 by EplPáj of PotterSoftware, Hungary
;
; Compile it with A86 3.22 .. 4.05 on DOS, generate quote52.com: a86 quote52.8
;
; Is this bug still present? !! This program prints garbage after the last
; quote (could not be reproduced), assuming CRLF + CRLF file ending.
;
; This source code is based on the disassembly of quote.com generated by A86
; 3.22, and abstractions were added based on quote4.nasm. The original,
; commented A86 source code was lost.
;
; The QUOTE.IDX index file format is identical in version 2.30 .. 2.5? and
; different from version 2.60.
;
; The most important update since V2.40 is that ANSI.SYS is no longer needed
; for color display. With ANSI.SYS, \x1B escapes were use when printing with
; with int 029h, now int 010h is used (color specified in bl, with AH=0Eh
; and AH=09h). The latter works in DOSBox as well.
;
; Command-line argument (first byte on the command-line):
;
; * ' '-> Display a quote using index table (default).
; * 'A'-> Display a quote using linear search.
; * 'B'-> Create index table & then display a quote using it.
; * 'C'-> Create index table.
;

jmp_near macro
  db 0e9h
  ;jmp long #1  ; This sometimes generates a short jump.
  dw (#1)-$-2
#em

full= 04000h
qqq_a= [018h]w
qqq_w= [01Ch]w
offset_qqq_l= 01Eh
offset_buf= 068h
offset_var_s= offset_buf

_code:
_start:
mov ax,ds  ; @0x100  8CD8
add ax,seg_delta  ; @  055400
mov ds,ax  ; @  8ED8
mov es,ax  ; es will remain this way for the rest of the run.
mov ax,ss  ; @  8CD0
add ax,0100h  ; @  050001
mov ss,ax  ; @  8ED0  ; !! Why modify ss? Do we need extra stack space?
mov bh,00h  ; @  B700
mov ax,0E0Dh  ; @  B80D0E
int 010h  ; @  CD10
mov al,0Ah  ; @  B00A
int 010h  ; @  CD10
db 06ah, headermsg_data  ;!! push byte +018h  ; @  6A18
call func_Header  ; @  E89003
mov al,[cs:081h]  ; @  2EA08100
cmp al,' '  ; @  3C20
jnz lx_12a  ; @  7504
mov al,[cs:082h]  ; @  2EA08200
lx_12a:
cmp byte [cs:080h],00h  ; @  2E803E800000
jnz lx_137  ; @  7505
mov byte [02Ch],' '  ; @  C6062C0020
lx_137:
and al,0DFh  ; @  24DF
mov [02Ch],al  ; @  A22C00
; XReset(IdxFn);
mov ax,03D00h  ; @  B8003D
mov dx,idxfn_data  ; @  BA0C00
int 021h  ; @  CD21
mov [02Eh],ax  ; @  A32E00
sbb ax,ax  ; @  1BC0
mov word [0406Dh],00h  ; @  C7066D400000
cmp ax,00h  ; @  3D0000
jnz lx_162  ; @  750A
cmp byte [02Ch],0Dh  ; @  803E2C000D
jnz lx_162  ; @  7503
jmp_near lls  ; @  E91101
lx_162:
mov ax,03D00h  ; @  B8003D
mov dx,txtfn_data  ; @  BA0000
int 021h  ; @  CD21
mov [02Eh],ax  ; @  A32E00
jnc lx_172  ; @  7303
jmp_near lx_462  ; @  E9F002
lx_172:
mov ax,04202h  ; @  B80242
mov bx,[02Eh]  ; @  8B1E2E00
xor cx,cx  ; @  33C9
xor dx,dx  ; @  33D2
int 021h  ; @  CD21
mov [022h],ax  ; @  A32200
mov [024h],dx  ; @  89162400
mov ax,04200h  ; @  B80042
mov bx,[02Eh]  ; @  8B1E2E00
xor cx,cx  ; @  33C9
xor dx,dx  ; @  33D2
int 021h  ; @  CD21
mov word [01Ah],full+4  ; @  C7061A000440
xor ax,ax  ; @  33C0
mov [offset_qqq_l],ax  ; @  A31E00
mov [offset_qqq_l+2],ax  ; @  A32000
mov [026h],ax  ; @  A32600
mov [028h],ax  ; @  A32800
mov word qqq_a,01h  ; @  C70618000100
mov [offset_buf+full], ax  ; Make sure we don't detect CRLF+CRLF at the beginning.

lx_1ad:
call func_GetNext  ; @  E8B602
mov si,offset_buf-4  ; @  BE6400
add si,[01Ah]  ; @  03361A00
cmp word [si],0A0Dh  ; @  813C0D0A
jnz lx_1f3  ; @  7536
cmp word [si+02h],0A0Dh  ; @  817C020D0A
jnz lx_1f3  ; @  752F
mov ax,[offset_qqq_l]  ; @  A11E00
mov dx,[offset_qqq_l+2]  ; @  8B162000
sub ax,[026h]  ; @  2B062600
sbb dx,[028h]  ; @  1B162800
mov di,0406Dh  ; @  BF6D40
add di,qqq_a  ; @  033E1800
add di,qqq_a  ; @  033E1800
mov [di],ax  ; @  8905
mov [di+02h],dx  ; @  895502
inc word qqq_a  ; @  FF061800
mov ax,[offset_qqq_l]  ; @  A11E00
mov [026h],ax  ; @  A32600
mov ax,[offset_qqq_l+2]  ; @  A12000
mov [028h],ax  ; @  A32800
lx_1f3:
mov ax,[022h]  ; @  A12200
mov dx,[024h]  ; @  8B162400
cmp [offset_qqq_l],ax  ; @  39061E00
jnz lx_1ad  ; @  75AD
cmp [offset_qqq_l+2],dx  ; @  39162000
jnz lx_1ad  ; @  75A7

; Now qqq.a == (number of quotes) + 1.
; close(f).
mov ah,03Eh  ; @  B43E
mov bx,[02Eh]  ; @  8B1E2E00
int 021h  ; @  CD21
cmp byte [02Ch],041h  ; @  803E2C0041
jnz lx_218  ; @  7503
jmp_near llc  ; @  E9AD00

lx_218:  ; Compress the index from offset_idx+2 to offset_buf.
; qqq_a is still the number of quotes.
mov cx,qqq_a  ; @  8B0E1800
dec cx  ; @  49
mov si,0406Fh  ; @  BE6F40
mov di,offset_buf  ; @  BF6800
xor dx,dx  ; @  33D2
lx_229:
lodsw  ; @  AD
stosb  ; @  AA
cmp ax,0F0h  ; @  3DF000
jc lx_238  ; @  7208
dec di  ; @  4F
rol ax, 8  ; @  C1C008
or ax,0F0h  ; @  0DF000
stosw  ; @  AB
lx_238:
loop lx_229  ; @  E2EF

sub di,offset_buf  ; DI := number of compressed bytes to write.
mov ah,03Ch  ; @  B43C
mov cx,00h  ; @  B90000
mov dx,idxfn_data  ; @  BA0C00
int 021h  ; @  CD21
jnc lx_252  ; @  7303
jmp_near lx_462  ; @  E91002
lx_252:
jnc lx_259  ; @  7305
mov ax,04CF0h  ; @  B8F04C
int 021h  ; @  CD21
lx_259:
; blockwrite(f, buf, compressed_size);
mov ah,040h  ; @  B440
mov bx,[02Eh]  ; @  8B1E2E00
mov cx,di  ; @  8B0E1800
mov dx,offset_buf  ; @  BA6800
int 021h  ; @  CD21
mov ah,03Eh  ; @  B43E
mov bx,[02Eh]  ; @  8B1E2E00
int 021h  ; @  CD21
jmp_near llc  ; @  E95200

lls:
mov ax,03D00h  ; @  B8003D
mov dx,idxfn_data  ; @  BA0C00
int 021h  ; @  CD21
mov [02Eh],ax  ; @  A32E00
jnc lx_283  ; @  7303
jmp_near lx_462  ; @  E9DF01
lx_283:
; blockread(f, buf, $FFFF, reg_cx);
mov ah,03Fh  ; @  B43F
mov bx,[02Eh]  ; @  8B1E2E00
mov cx,0FFFFh  ; @  B9FFFF
mov dx,offset_buf  ; @  BA6800
int 021h  ; @  CD21
mov cx,ax  ; @  A31800  ; Save number of (compressed) bytes read to cx, for below.
mov ah,03Eh  ; @  B43E
mov bx,[02Eh]  ; @  8B1E2E00
int 021h  ; @  CD21

; Decompress the index from buf to idx+2.
mov dx,01h  ; @  BA0100
mov si,offset_buf  ; @  BE6800
mov di,0406Fh  ; @  BF6F40
lx_2ad:
lodsb  ; @  AC
mov ah,00h  ; @  B400
stosw  ; @  AB
cmp al,0F0h  ; @  3CF0
jc lx_2be  ; @  7209
dec di  ; @  4F
dec di  ; @  4F
and al,0Fh  ; @  240F
mov ah,al  ; @  88C4
lodsb  ; @  AC
stosw  ; @  AB
dec cx  ; @  49
lx_2be:
inc dx  ; @  42
loop lx_2ad  ; @  E2EC
mov qqq_a,dx  ; @  89161800  ; qqq.a := (number of quotes) + 1.

llc:
cmp byte [02Ch],043h  ; @  803E2C0043
jnz lx_2cf  ; @  7503
jmp_near lx_462  ; @  E99301
lx_2cf:
mov ax,03D00h  ; @  B8003D
mov dx,txtfn_data  ; @  BA0000
int 021h  ; @  CD21
mov [02Eh],ax  ; @  A32E00
jnc lx_2df  ; @  7303
jmp_near lx_462  ; @  E98301
lx_2df:
; Now qqq_a-1 is the number of quotes in txtfn, provided that txtfn ends with CRLF + CRLF.
xor ax, ax
mov [offset_qqq_l], ax  ; L kezdőoffszet kiszámolása
mov [offset_qqq_l+2], ax
mov si, qqq_a
test si, si
jz after_random  ; If there are 0 quotes, print from the beginning of txtfn.
dec si  ; SI := Number of quotes.

; DX:=random(SI);  Then 0 <= SI < DX.
; This code may ruin AX, BX, CX, SI, DI, BP and FLAGS.
;
; This code generates a 32-bit random number n in a register pair, then computes
; qqq_w := (n * (qqq_a + 1)) >> 32 as the random value.
;mov ah, 0  ; Not needed, AX=0 above.
int 01Ah  ; Get time-random seed in CX:DX.
xor bp, bp
mov ax, cs
add ax, dx  ; Modify seed.
mov bx, ax
mov dx, 08405h
mul dx
shl bx, 3
add ch, cl
add dx, bx
add dx, cx
shl cx, 2
add dx, cx
add dh, bl
shl cx, 5
add ax, 1  ; Modifies CF (inc ax doesn't)..
adc dx, bp
mov bx, dx
mul si
mov ax, bx
mov bx, dx
mul si
add ax, bx
adc dx, bp  ; DX:=random(SI)
jz after_random  ; If the chosen random number is 0, print from the beginning of txtfn.

mov si,0406Dh  ; @  BE6D40
add si,dx  ; @  03361C00
add si,dx  ; @  03361C00
std  ; @  FD
lx_322:
lodsw  ; @  AD
add [offset_qqq_l],ax  ; @  01061E00
adc word [offset_qqq_l+2], 0  ; db 083h, 016h, offset_qqq_l+2, 0, 0  ; adc word [offset_qqq_l+2],byte +00h  ; @  8316200000
cmp si,0406Dh  ; @  81FE6D40
jnz lx_322  ; @  75F0
cld  ; @  FC

after_random:
mov dx,0BFDAh  ; @  BADABF  ; '┌┐'  ; Keret ki
call func_PrintLine  ; @  E8D401
lx_339:
mov ax,04200h  ; @  B80042
mov bx,[02Eh]  ; @  8B1E2E00
mov dx,[offset_qqq_l]  ; @  8B161E00
mov cx,[offset_qqq_l+2]  ; @  8B0E2000
int 021h  ; @  CD21
mov ah,03Fh  ; @  B43F
mov bx,[02Eh]  ; @  8B1E2E00
mov cx,0FFh  ; @  B9FF00
mov dx,offset_var_s+1  ; @  BA6900
int 021h  ; @  CD21
mov qqq_w,ax  ; @  A31C00
cmp ax,00h  ; @  3D0000
jnz lx_363  ; @  7503
jmp_near lx_448  ; @  E9E500
lx_363:
mov bx,00h  ; @  BB0000
mov si,offset_var_s+1  ; @  BE6900
lx_369:
or bh,bh  ; @  0AFF
jnz lx_375  ; @  7508
cmp byte [bx+si],0Dh  ; @  80380D
jz lx_378  ; @  7406
inc bx  ; @  43
jmp short lx_369  ; @  EBF4
lx_375:
jmp_near lx_462  ; @  E9EA00
lx_378:
mov [offset_var_s],bl  ; @  881E6800
inc bx  ; @  43
inc bx  ; @  43
add [offset_qqq_l],bx  ; @  011E1E00
adc word [offset_qqq_l+2], 0  ; db 083h, 016h, offset_qqq_l+2, 0, 0 ; adc word [offset_qqq_l+2],byte +00h  ; @  8316200000
mov cx,ds  ; @  8CD9
mov si,offset_var_s  ; @  BE6800
mov qqq_w,si  ; @  89361C00
lodsb  ; @  AC
cmp al,00h  ; @  3C00
jnz lx_39c  ; @  7507
mov al,01h  ; @  B001
mov ds,cx  ; @  8ED9
jmp_near lx_441  ; @  E9A500
lx_39c:
mov byte [02Dh],00h  ; @  C6062D0000
cmp byte [si],02Dh  ; @  803C2D
jnz lx_3b9  ; @  7513
mov al,[si+01h]  ; @  8A4401
mov [02Dh],al  ; @  A22D00
add word qqq_w, 2  ; db 083h, 006h, 01ch, 0, 2  ; add word [01Ch],byte +02h  ; @  83061C0002
mov al,[si-01h]  ; @  8A44FF
dec ax  ; @  48
dec ax  ; @  48
mov [si+01h],al  ; @  884401
lx_3b9:
mov ah,00h  ; @  B400
mov ds,cx  ; @  8ED9
mov bx,04Eh  ; @  BB4E00
mov cx,0Fh  ; @  B90F00
cmp byte [02Dh],00h  ; @  803E2D0000
jnz lx_3d5  ; @  750B
mov al,00h  ; @  B000
mov bx,00h  ; @  BB0000
mov cx,07h  ; @  B90700
jmp_near lx_3e4  ; @  E90F00
lx_3d5:
cmp byte [02Dh],026h  ; @  803E2D0026
jnz lx_3e4  ; @  7508
mov bx,027h  ; @  BB2700
shr ax,1  ; @  D1E8
mov cx,0Ah  ; @  B90A00
lx_3e4:
sub bx,ax  ; @  29C3
mov [02Ah],bx  ; @  891E2A00
mov ax,0EB3h  ; @  B8B30E
mov bh,00h  ; @  B700
int 010h  ; @  CD10
mov bx,cx  ; @  8BD9
mov cx,04Eh  ; @  B94E00
call lx_526  ; @  E82D01

mov si,qqq_w  ; @  8B361C00
lodsb  ; @  AC
mov cl,al  ; @  88C1
mov ch,00h  ; @  B500
mov dx,cx  ; @  8BD1
jcxz lx_437  ; @  E330
mov cx,[02Ah]  ; @  8B0E2A00
jcxz lx_416  ; @  E309
mov ax,0E20h  ; @  B8200E
mov bh,00h  ; @  B700
lx_412:
int 010h  ; @  CD10
loop lx_412  ; @  E2FC
lx_416:
mov cx,dx  ; @  8BCA
jcxz lx_423  ; @  E309
mov ah,0Eh  ; @  B40E
mov bh,00h  ; @  B700
lx_41e:
lodsb  ; @  AC
int 010h  ; @  CD10
loop lx_41e  ; @  E2FB
lx_423:
mov cx,04Eh  ; @  B94E00
sub cx,[02Ah]  ; @  2B0E2A00
sub cx,dx  ; @  29D1
jcxz lx_437  ; @  E309
mov ax,0E20h  ; @  B8200E
mov bh,00h  ; @  B700
lx_433:
int 010h  ; @  CD10
loop lx_433  ; @  E2FC
lx_437:

mov ax,0EB3h  ; @  B8B30E
mov bh,00h  ; @  B700
int 010h  ; @  CD10
mov al,00h  ; @  B000
lx_441:
or al,al  ; @  0AC0
jnz lx_448  ; @  7503
jmp_near lx_339  ; @  E9F1FE
lx_448:
mov dx,0D9C0h  ; @  BAC0D9
call func_PrintLine  ; @  E8BF00
db 06ah, footermsg_data  ;!! push byte +03Bh  ; @  6A3B
call func_Header  ; @  E85A00
mov ah,03Eh  ; @  B43E
mov bx,[02Eh]  ; @  8B1E2E00
int 021h  ; @  CD21
mov bx,07h  ; @  BB0700
call lx_523  ; @  E8C100
lx_462:
mov ah,04Ch  ; @  B44C
int 021h  ; @  CD21

; May ruin SI and possibly other registers.
func_GetNext:
cmp word [01Ah],full+4  ; @  813E1A000440
jnz lx_498  ; @  752A
; move(src:=buf[full], dst:=buf[0], 4);
  mov si, offset_buf + full
  mov di, offset_buf
  movsw
  movsw
mov ah,03Fh  ; @  B43F
mov bx,[02Eh]  ; @  8B1E2E00
mov cx,full  ; @  B90040
mov dx,offset_buf+4  ; @  BA6C00
int 021h  ; @  CD21
jnc lx_492  ; @  7505
mov ax,04CF1h  ; @  B8F14C  ; Abort on read error.
int 021h  ; @  CD21
lx_492:
mov word [01Ah],04h  ; @  C7061A000400
lx_498:
mov bx,[01Ah]  ; @  8B1E1A00
mov al,[bx+offset_buf]  ; @  8A4768
inc word [01Ah]  ; @  FF061A00
add word [offset_qqq_l], 1  ; db 083h, 006h, 01eh, 0, 1 ; add word [offset_qqq_l],byte +01h  ; @  83061E0001
adc word [offset_qqq_l+2], 0  ; db 083h, 016h, offset_qqq_l+2, 0, 0 ; adc word [offset_qqq_l+2],byte +00h  ; @  8316200000
ret  ; @  C3

func_Header:
push bp  ; @  55
mov bp,sp  ; @  89E5
mov bx,010h  ; @  BB1000
call lx_523  ; @  E86C00
mov ax,0EB2h  ; @  B8B20E
mov byte [cs:ploop2],048h  ; @  2EC606390548  ; 48h: DEC AX
call lx_52c  ; @  E86900
mov si,[bp+04h]  ; @  8B7604
lodsb  ; @  AC
mov ah,00h  ; @  B400
mov dx,ax  ; @  8BD0
shr ax,1  ; @  D1E8
mov cx,019h  ; @  B91900
sub cx,ax  ; @  2BC8
mov bp,cx  ; @  89CD
mov ax,0E20h  ; @  B8200E
mov bh,00h  ; @  B700
jcxz lx_4df  ; @  E304
lx_4db:
int 010h  ; @  CD10
loop lx_4db  ; @  E2FC
lx_4df:
mov cx,[si-01h]  ; @  8B4CFF
mov ch,00h  ; @  B500
lx_4e4:
lodsb  ; @  AC
int 010h  ; @  CD10
loop lx_4e4  ; @  E2FB
mov cx,032h  ; @  B93200
sub cx,bp  ; @  2BCD
sub cx,dx  ; @  29D1
mov al,020h  ; @  B020
jcxz lx_4f8  ; @  E304
lx_4f4:
int 010h  ; @  CD10
loop lx_4f4  ; @  E2FC
lx_4f8:
mov al,0B0h  ; @  B0B0
mov byte [cs:ploop2],040h  ; @  2EC606390540  ; 40h: INC AX
call lx_52c  ; @  E82900
mov bx,07h  ; @  BB0700
call lx_523  ; @  E81A00
pop bp  ; @  5D
ret 02h  ; @  C20200

func_PrintLine:
mov ah,0Eh  ; @  B40E
mov bh,00h  ; @  B700
mov al,dl  ; @  8AC2
int 010h  ; @  CD10
mov cx,04Eh  ; @  B94E00
mov al,0C4h  ; @  B0C4
lx_51a:
int 010h  ; @  CD10
loop lx_51a  ; @  E2FC
mov al,dh  ; @  8AC6
int 010h  ; @  CD10
ret  ; @  C3
lx_523:
mov cx,050h  ; @  B95000
lx_526:
mov ax,0920h  ; @  B82009
int 010h  ; @  CD10
ret  ; @  C3
lx_52c:
mov cx,03h  ; @  B90300
lx_52f:
int 010h  ; @  CD10
int 010h  ; @  CD10
int 010h  ; @  CD10
int 010h  ; @  CD10
int 010h  ; @  CD10
ploop2:
dec ax  ; @  48  ; Self-modifying code will modify this to `dec ax' or `inc ax'.
loop lx_52f  ; @  E2F3
ret  ; @  C3

db ((_code-$) and 15) dup 090h  ; Align to paragraph (16) boundary with nop.
seg_delta= (($-_code) shr 4)+010h
_data:

;=======Kezdőértékes adatok
txtfn:	db 'QUOTE.TXT',0,0,0  ; Extra 0s because of _bss overlap with headermsg.
txtfn_data equ txtfn-_data
idxfn:	db 'QUOTE.IDX',0,0,0  ; Extra 0s because of _bss overlap with headermsg.
idxfn_data equ idxfn-_data
headermsg:	db 34,'PotterSoftware Quote Displayer 2.5'
headermsg_data equ headermsg-_data
footermsg:	db 44,'Greetings to RP,TT,FZ/S,Blala,OGY,FC,VR,JCR.'
footermsg_data equ footermsg-_data

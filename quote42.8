; -*- coding: utf-8 -*-
;
; quote42.8: PotterSoftware Quote Displayer V2.42 (NASM source code)
; (C) 1996--2022-03-27 by EplPáj of PotterSoftware, Hungary
; translation to NASM on 2022-03-27
;
; Compile it with NASM 0.98.39 .. 2.13.02 ...:
;
;   nasm -O0 -f bin -o quote42n.com quote42.8
;
; Alternatively, compile it with Yasm 1.2.0 or 1.3.0:
;
;   yasm -O0 -f bin -o quote42n.com quote42.8
;
; Alternatively, compile it with A86 3.22 .. 4.05 on DOS, generate quote42.com:
;
;   a86 quote42.8
;
; Alternatively, compile it with A86 3.22 .. 4.05 with DOSBox on Linux,
; generate quote42.com:
;
;   ./runa86.sh a86 quote42.8
;
; This is version 2.42, which is version 2.41 with some critical bugfixes.
;
; The QUOTE.IDX index file format is identical in version 2.30 .. 2.5? and
; different from version 2.60.
;
; This source code is based on the disassembly of quote3.exe generated by
; the Turbo Pascal compiler (tp70), but it has been changed since then to
; make it work as a DOS .com program, and it is also based on the source
; code quote3.pas, matching its assembly instructions as closely as possible.
; Since then some bugs were fixed.
;
; It uses ANSI.SYS for color output, and it detects the lack of ANSI.SYS, and
; then it prints colorless output.
;
; Command-line argument (first byte on the command-line):
;
; * ' '-> Display a quote using index table (default).
; * 'A'-> Display a quote using linear search.
; * 'B'-> Create index table & then display a quote using it.
; * 'C'-> Create index table.
;

; These magic lines below load the assembler compatibility library in file
; nasm.8, which makes the rest of the code work with the assemblers
; A86 >=3.22, NASM >=0.98.39, Yasm >=1.2.0. Please note that A86 3.22 doesn't
; support `include', so to make it work, replace these lines with the contents
; of the file nasm.8, or use runa86.sh to automate it.
%define macro  ; NASM + Yasm code follows (no A86).
%macro include 1
%include %1
%endm
%define __EM__ #em  ; End of NASM + Yasm code.
include 'nasm.8'

org 100h
bits 16
cpu 286  ; Some instructions below (such as higher-than-1 bit shifts) need 286.

full equ 16384  ; Just a size (04000h).
_bss_data equ 032h  ; Overlaps the beginning of headermsg. Unfortunately it's not possible to precompute in A86 3.22.
;_bss_data equ headermsg  ; This forward-declaration doesn't work in A86.

; _bss variables.
qqq_a equ _bss_data-018h+018h  ; w
qqq_b equ _bss_data-018h+01Ah  ; w
qqq_w equ _bss_data-018h+01Ch  ; w
qqq_llw equ _bss_data-018h+01Eh  ; w
qqq_lhw equ _bss_data-018h+020h  ; w
qqq_maxlw equ _bss_data-018h+022h  ; w
qqq_maxhw equ _bss_data-018h+024h  ; w
qqq_oldllw equ _bss_data-018h+026h  ; w
qqq_oldlhw equ _bss_data-018h+028h  ; w
qqq_xch equ _bss_data-018h+02Ah  ; b  ; Contains the command-line argument character: 0 for missing or space (' '), otherwise uppercased ('A' to 'C').
qqq_before equ _bss_data-018h+02Bh  ; w  ; Not aligned.
qqq_ansich equ _bss_data-018h+02Dh  ; b
qqq_han equ _bss_data-018h+02Eh  ; w  ; Filehandle.

_code:
_start:  ; begin { program entry point }
	; Increase DS and SS to accommodate for the total memory usage of 68 KiB (67
	; KiB for code and data + 1 KiB for stack).
	mov ah, 4Ah  ; https://stanislavs.org/helppc/int_21-4a.html
	mov bx, 1100h  ; Number of bytes needed == 1100h * 16, that's 68 KiB.
	int 21h
	jnc resize_ok
	jmp_near fatal_error
resize_ok:
	mov ax, ds
	add ax, word_arg(seg_delta)
	mov ds, ax
	mov es, ax  ; es will remain this way for most of the rest of the run.
	mov ax, ss
	add ax, 100h  ; 1 KiB of stack at the end of the 68 KiB.
	mov ss, ax

main:	mov ah, 2
	mov dl, 13  ; Writeln
	int 21h
	mov dl, 10
	int 21h

	; Detect ANSI.SYS.
	;
	; From http://www.osfree.org/doku/en:docs:dos:api:int29 :
	; COMMAND.COM v3.2 and v3.3 compare the INT 29 vector against the INT 20
	; vector and assume that ANSI.SYS is installed if the segment is larger.
	;
	; To do so, we should use `ja' instead of `jae' below, but then it
	; wouldn't detect the built-in ANSI.SYS in DOSBox 0.74-4 (for which the
	; segments are equal). Please note that neither is correct for
	; MS-DOS 6.22, because both report ANSI.SYS is installed even if it isn't.
	push es
	xor ax, ax
	mov es, ax
	mov bx, [es:29h*4+2]  ; ansi:=memw[0:$29*4+2]>memw[0:$20*4+2];
	cmp bx, [es:20h*4+2]
	pop es
	jae @95
	mov byte [offset ttt], '*'  ; This means there's no ANSI.SYS
@95:

	push_word offset headermsg  ; TODO: Use push_byte.
	call func_Header  ; Print header.

	; Get parameter from beginning of command-line arguments.
	mov al, [81h]  ; First character of command-line arguments in PSP.  ; xch:=char(mem[PrefixSeg:$81]);
	cmp al, ' '
	jne @96  ; if xch=' ' then xch:=char(mem[PrefixSeg:$82]);
	mov al, [82h]
@96:	cmp byte [80h], 0h  ; if mem[PrefixSeg:$80]=0 then xch:=' ';
	jne @94
	mov al, ' '
@94:	and al, 255-32
	mov [qqq_xch], al

	; qqq_w:=XReset(IdxFn);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, offset idxfn
	int 21h
	mov [qqq_han], ax
	sbb ax, ax  ; AX:=0 if ok; AX:=$FFFF on error.
	mov word [offset idx], 0  ; idx[0]:=0
	cmp ax, word_arg(0)  ; if (IOResult<>0) or (xch<>#0) then
	jne @90
	cmp byte [qqq_xch], 0
	jne @90
	jmp_near lls
@90:	; XReset(TXTFN);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, offset txtfn
	int 21h
	mov [qqq_han], ax
	jnc @90_nc
	jmp_near fatal_error
@90_nc:	; qqq_max:=filesize(f);
	mov ax, 4202h
	mov bx, [qqq_han]
	xor cx, cx
	xor dx, dx
	int 21h
	mov [qqq_maxlw], ax
	mov [qqq_maxhw], dx
	mov ax, 4200h
	mov bx, [qqq_han]
	xor cx, cx
	xor dx, dx
	int 21h
	mov word [qqq_b], full+4  ; b:=full+4
	xor ax, ax
	mov [qqq_llw], ax  ; l:=0
	mov [qqq_lhw], ax
	mov [qqq_oldllw], ax  ; oldl:=0
	mov [qqq_oldlhw], ax
	mov word [qqq_a], 1
	mov [offset buf+full], ax  ; Make sure we don't detect CRLF+CRLF at the beginning.
@81:	; repeat
	call func_GetNext
	mov si, offset buf-4
	add si, [qqq_b]
	cmp word [si], 0A0Dh  ; CRLF
	jne @82
	cmp word [si+2h], 0A0Dh  ; CRLF
	jne @82  ;  if buf[b-4]=newline then begin
	mov ax, [qqq_llw]  ;    idx[a]:=l-oldl
	mov dx, [qqq_lhw]
	sub ax, [qqq_oldllw]
	sbb dx, [qqq_oldlhw]
	mov di, offset idx
	add di, [qqq_a]
	add di, [qqq_a]
	mov [di], ax
	mov [di+2], dx
	inc word [qqq_a]
	mov ax, [qqq_llw]  ;    oldl:=l
	mov [qqq_oldllw], ax
	mov ax, [qqq_lhw]
	mov [qqq_oldlhw], ax  ;  end;
@82:	mov ax, [qqq_maxlw]  ; until l=max
	mov dx, [qqq_maxhw]
	cmp [qqq_llw], ax
	jne @81
	cmp [qqq_lhw], dx
	jne @81

	; Now qqq.a == (number of quotes) + 1.
	; close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h
	cmp byte [qqq_xch], 'A'  ; Don't write the index file on parameter 'A'.
	jne @82_ne
	jmp_near llc
@82_ne:	mov cx, [qqq_a]
	dec cx
	mov si, offset idx+2
	mov di, offset buf
	xor dx, dx
@83:	lodsw
	stosb
	cmp ax, 240
	jb @84
	dec di
	rol ax, 8
	or ax, 240  ; 11110000b
	stosw
@84:	loop @83
	sub di, offset buf  ; DI := number of compressed bytes to write.

	; XRewrite(IDXFN);
	mov ah, 3Ch  ; Create file
	mov cx, 0
	mov dx, offset idxfn
	int 21h
	jnc @91
fatal_error:
	mov ax, 4CF0h  ; Fatal error
	int 21h
	; blockwrite(f, buf, compressed_size);
@91:	mov ah, 40h
	mov bx, [qqq_han]
	mov cx, di
	mov dx, offset buf
	int 21h
	; close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h
	; goto c;
	jmp_short llc

lls:  ; end else begin
	; XReset(IDXFN);
	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, offset idxfn
	int 21h
	mov [qqq_han], ax
	jc fatal_error
	; blockread(f, buf, full+4, reg_ax);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, full+4
	mov dx, offset buf
	int 21h
	mov cx, ax  ; Save number of (compressed) bytes read to CX, for below.
	; close(f);
	mov ah, 3Eh
	mov bx, [qqq_han]
	int 21h

	mov dx, 1
	mov si, offset buf
	mov di, offset idx+2
@85:	lodsb
	mov ah, 0
	stosw
	cmp al, 240
	jb @86
	dec di
	dec di
	and al, 15
	mov ah, al
	lodsb
	stosw
	dec cx
@86:	inc dx
	loop @85
	mov [qqq_a], dx  ; qqq.a := (number of quotes) + 1.
llc:	cmp byte [qqq_xch], 'C'
	jne @ne2
	jmp_near llf
	; XReset(TXTFN);
@ne2:	mov ax, 3D00h  ; Open for Read Only, C-Mode
	mov dx, offset txtfn
	int 21h
	mov [qqq_han], ax
	jc fatal_error
	; Now qqq_a-1 is the number of quotes in offset txtfn, provided that offset txtfn ends with CRLF + CRLF.
	xor ax, ax
	mov [qqq_llw], ax
	mov [qqq_lhw], ax
	mov si, [qqq_a]
	test si, si
	jz after_random  ; If there are 0 quotes, print from the beginning of offset txtfn.
	dec si  ; SI := Number of quotes.

	; DX:=random(SI);  Then 0 <= SI < DX.
	; This code may clobber AX, BX, CX, SI, DI, BP and flags.
	;
	; This code generates a 32-bit random number n in a register pair, then computes
	; DX := (n * SI) >> 32 as the random value.
	;mov ah, 0  ; Not needed, AX=0 above.
	int 1Ah  ; Get time-random seed in CX:DX.
	xor bp, bp
	mov ax, cs
	add ax, dx  ; Modify seed.
	mov bx, ax
	mov dx, 8405h
	mul dx
	shl bx, 3
	add ch, cl
	add dx, bx
	add dx, cx
	shl cx, 2
	add dx, cx
	add dh, bl
	shl cx, 5
	add ax, word_arg(1)  ; Modifies CF (inc ax doesn't)..
	adc dx, bp
	mov bx, dx
	mul si
	mov ax, bx
	mov bx, dx
	mul si
	add ax, bx
	adc dx, bp  ; DX:=random(SI)
	jz after_random  ; If the chosen random number is 0, print from the beginning of offset txtfn.

	; Calculate the start offset of quote qqq.w into qqq.l:
	; qqq.l := idx[qqq.w] + idx[qqq.w-1] + ... + idx[qqq.1].
	mov si, offset idx
	add si, dx
	add si, dx
	std
@97:	lodsw
	add [qqq_llw], ax
	adc word [qqq_lhw], byte_arg(0)
	cmp si, offset idx
	jne @97
	cld

after_random:
	push_word 0BFDAh  ; Print border '┌┐'.
	call func_PrintLine

lld:	; seek(f, qqq_l);
	mov ax, 4200h
	mov bx, [qqq_han]
	mov dx, [qqq_llw]
	mov cx, [qqq_lhw]
	int 21h
	; blockread(f, s[1], 255, qqq_w);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, 255
	mov dx, offset var_s+1
	int 21h
	mov [qqq_w], ax

	cmp word [qqq_w], byte_arg(0)  ; Stop at EOF.
	jne @ne1
	jmp_near lle
@ne1:	mov bx, 0h  ; Look for #13 to determine length(s)
	mov si, offset var_s+1
@12:	or bh, bh
	jnz @13
	cmp byte [si+bx], 13
	je @11
	inc bx
	jmp_short @12
@13:	jmp_near fatal_error  ; Error: Line longer than 255 bytes.
@11:	; Beállítjuk a string hosszát
	dw 1E88h, offset var_s  ; mov byte [offset var_s], bl  ; Workaround to prevent bug in yasm-1.2.0 and yasm-1.3.0: INTERNAL ERROR at modules/arch/x86/x86expr.c, line 417: unexpected expr op
	inc bx
	inc bx
	add [qqq_llw], bx  ; inc(l,length(s)+2);
	adc word [qqq_lhw], byte_arg(0)

	; START OF ALIGN
	;
	; If S='' align returns TRUE else it returns FALSE. Align prints S with the
	; correct color & alignment according to the control codes found in S[1, 2].

	; Calculate the value of BEFORE first using up AnsiCh: #0=Left '-'=Right
	; '&'=Center alignment
	mov si, offset var_s
	mov [qqq_w], si
	lodsb
	cmp al, 0
	jne @d
	mov al, 1
	jmp_near @9  ; Empty string: do nothing but restore original CS
@d:	mov byte [qqq_ansich], 0  ; AnsiCh is 0 by default
	cmp byte [si], '-'
	jne @c
	mov al, [si+1]
	mov [qqq_ansich], al
	add word [qqq_w], byte_arg(2)  ; If not AnsiCh<>0 the 1st 2 char won't be in the str
	mov al, [si-1]
	dec ax
	dec ax
	mov [si+1h], al
@c:	mov ah, 0
	mov bx, 78
	mov cl, '7'
	cmp byte [qqq_ansich], 0
	jne @a
	mov al, 0
	mov bx, 0
@a:	cmp byte [qqq_ansich], '&'
	jne @b
	mov cl, '2'
	mov bx, 39
	shr ax, 1
@b:	mov [offset ttt+17+3], cl  ; Set ANSI color of aligned text.
	sub bx, ax
	mov [qqq_before], bx
	mov ah, 2
	mov dl, 0B3h  ; '│'  ; The line starts by this
	int 21h
	cmp byte [offset ttt], '*'  ; Put out an ANSI EscSeq to set color if needed
	je @6
	mov ah, 9
	mov al, [qqq_ansich]
	cmp al, 0
	je @6
	add al, 10
	mov dx, offset ttt+17
	int 21h
	mov byte [qqq_ansich], 0h
@6:	; Display the string "s" with "before" spaces in front of it
	mov si, [qqq_w]
	lodsb
	mov cl, al
	mov ch, 0
	jcxz @1
	push cx
	mov cx, [qqq_before]
	mov ah, 2
	jcxz @5
	mov dl, ' '
@2:	int 21h
	loop @2
@5:	pop cx
	push cx
	jcxz @8
@3:	lodsb
	mov dl, al
	int 21h
	loop @3
@8:	pop dx
	mov cx, 78
	sub cx, [qqq_before]
	sub cx, dx
	mov ah, 2
	jcxz @1
	mov dl, ' '
@4:	int 21h
	loop @4
@1:	cmp byte [offset ttt], '*'  ; Restore original color via ANSI EscSeq if needed
	je @7
	mov ah, 9
	mov dx, offset ttt+25
	int 21h
@7:	mov ah, 2
	mov dl, 0B3h  ; '│'  ; The line ends by this, too
	int 21h
	mov al, 0 ; The return value is FALSE
	; END OF ALIGN

@9:	or al, al
	jnz lle
	jmp_near lld  ; Line not empty, print next line.

lle:	; Print border and footer, then exit to DOS with EXIT_SUCCESS (0).
	push_word 0D9C0h  ; Print border '└┘'.
	call func_PrintLine
	push_word offset footermsg  ; TODO: Use push_byte.
	call func_Header
	mov ah, 3Eh  ; close(F);
	mov bx, [qqq_han]
	int 21h
llf:	mov ax, 4C00h  ; EXIT_SUCCESS (0).
	int 21h  ; Exit to DOS.

; function GetNext: char; assembler;
func_GetNext:
	cmp word [qqq_b], full+4  ; if qqq_b=full+4 then begin
	jne @88  ; No special meaning for @ in nasm, it's just a normal label character.
	; move(src:=buf[full], dst:=buf[0], 4);
	  mov si, offset buf + full
	  mov di, offset buf
	  movsw
	  movsw
	; blockread(f, buf[4], full, qqq_w);
	mov ah, 3Fh
	mov bx, [qqq_han]
	mov cx, full
	mov dx, offset buf+4
	int 21h
	jnc @87
	mov ax, 4CF1h  ; Abort on read error.
	int 21h
@87:	mov word [qqq_b], 4  ; endif
@88:	mov bx, [qqq_b]  ; GetNext:=Buf[qqq_B];
	mov al, [bx+offset buf]
	inc word [qqq_b]
	add word [qqq_llw], byte_arg(1)  ; inc(qqq_l);
	adc word [qqq_lhw], byte_arg(0)
	ret

; procedure Header(const s: OpenString); assembler;
func_Header:
defarg Header_arg_s, [bp+4]
	push bp
	mov bp, sp
	cmp byte [offset ttt], '*'
	je @71
	mov dx, offset ttt+25
	mov ah, 9
	int 21h
	mov dx, offset ttt
	mov ah, 9
	int 21h
@71:	mov ah, 2
	mov dl, 0B2h  ; '▓'
	mov cx, 3
@72:	int 21h
	int 21h
	int 21h
	int 21h
	int 21h
	dec dl
	loop @72
	mov si, Header_arg_s
	lodsb
	mov ah, 0
	push ax
	shr ax, 1
	mov cx, 25
	sub cx, ax
	mov bx, cx
	mov ah, 2
	mov dl, ' '
	jcxz @74
@75:	int 21h
	loop @75
@74:	mov cx, [si-1]
	mov ch, 0h
@76:	lodsb
	mov dl, al
	int 21h
	loop @76
	mov cx, 50
	sub cx, bx
	pop dx
	sub cx, dx
	mov ah, 2
	mov dl, ' '
	jcxz @78
@77:	int 21h
	loop @77
@78:	mov ah, 2
	mov dl, 0B0h  ; '░'
	mov cx, 3
@73:	int 21h
	int 21h
	int 21h
	int 21h
	int 21h
	inc dl
	loop @73
	cmp byte [offset ttt], '*'
	je @79
	mov dx, offset ttt+9
	mov ah, 9h
	int 21h
@79:	leave
	ret 2

; procedure PrintLine(w: word); assembler;
func_PrintLine:
defarg PrintLine_arg_wl, byte[bp+4]
defarg PrintLine_arg_wh, byte[bp+5]
	push bp
	mov bp, sp
	mov ah, 2
	mov dl, PrintLine_arg_wl
	int 21h
	mov cx, 78
	mov dl, 0C4h  ; '─'
@70:	int 21h
	loop @70
	mov dl, PrintLine_arg_wh
	int 21h
	leave
	ret 2

_code_padding:
	times_db ((_code - $) AND 15), 090h  ; Align to paragraph (16) boundary with nop.
seg_delta equ (($-_code) SHR 4) + 10h

; Data with initial value (_data).
_data:
ttt_in_data: db 27, '[44;30m$'
	db 27, '[0m', 27, '[K$'
	db 27, '[30;1m$'  ; The number '0' will be modified by code.
	db 27, '[0m$'
ttt equ ttt_in_data-_data  ; Because of seg_delta.
txtfn_in_data: db 'QUOTE.TXT',0
txtfn equ txtfn_in_data-_data  ; Because of seg_delta.
idxfn_in_data: db 'QUOTE.IDX',0
idxfn equ idxfn_in_data-_data  ; Because of seg_delta.
;_bss_data equ $-_data  ; It's too late to define a forward reference like this in A86 3.22.
; Must be long enough (23 bytes) for overlap with qqq_... .
headermsg_in_data: db 35, 'PotterSoftware Quote Displayer 2.42'
headermsg equ headermsg_in_data-_data  ; Because of seg_delta.
footermsg_in_data: db 44, 'Greetings to RP,TT,FZ/S,Blala,OGY,FC,VR,JCR.'
footermsg equ footermsg_in_data-_data  ; Because of seg_delta.
_data_end:

; More _bss: (Uninitialized data.)
buf equ _data_end-_data+((_data_end-_data) AND 1)  ; array[0..full+4-1] of char;  ; full+1+4 bytes used for multiple purposes.  ; Aligned.
var_s equ buf  ; string; overlaps buf
idx equ buf+full+4+((buf+full+4) AND 1)  ; array[0..24160] of word;  ; Aligned. idx[0] is unused.

assert0 _bss_data-headermsg  ; Make sure `_bss_data equ' above is correct.
